"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.tsx
var src_exports = {};
__export(src_exports, {
  usePdf: () => usePdf
});
module.exports = __toCommonJS(src_exports);
var import_react = require("react");
var pdfjs = __toESM(require("pdfjs-dist"));
function isFunction(value) {
  return typeof value === "function";
}
var usePdf = ({
  canvasRef,
  file,
  onDocumentLoadSuccess,
  onDocumentLoadFail,
  onPageLoadSuccess,
  onPageLoadFail,
  onPageRenderSuccess,
  onPageRenderFail,
  scale = 1,
  rotate = 0,
  page = 1,
  cMapUrl,
  cMapPacked,
  workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjs.version}/pdf.worker.js`,
  withCredentials = false
}) => {
  const [pdfDocument, setPdfDocument] = (0, import_react.useState)();
  const [pdfPage, setPdfPage] = (0, import_react.useState)();
  const renderTask = (0, import_react.useRef)(null);
  const onDocumentLoadSuccessRef = (0, import_react.useRef)(onDocumentLoadSuccess);
  const onDocumentLoadFailRef = (0, import_react.useRef)(onDocumentLoadFail);
  const onPageLoadSuccessRef = (0, import_react.useRef)(onPageLoadSuccess);
  const onPageLoadFailRef = (0, import_react.useRef)(onPageLoadFail);
  const onPageRenderSuccessRef = (0, import_react.useRef)(onPageRenderSuccess);
  const onPageRenderFailRef = (0, import_react.useRef)(onPageRenderFail);
  (0, import_react.useEffect)(() => {
    onDocumentLoadSuccessRef.current = onDocumentLoadSuccess;
  }, [onDocumentLoadSuccess]);
  (0, import_react.useEffect)(() => {
    onDocumentLoadFailRef.current = onDocumentLoadFail;
  }, [onDocumentLoadFail]);
  (0, import_react.useEffect)(() => {
    onPageLoadSuccessRef.current = onPageLoadSuccess;
  }, [onPageLoadSuccess]);
  (0, import_react.useEffect)(() => {
    onPageLoadFailRef.current = onPageLoadFail;
  }, [onPageLoadFail]);
  (0, import_react.useEffect)(() => {
    onPageRenderSuccessRef.current = onPageRenderSuccess;
  }, [onPageRenderSuccess]);
  (0, import_react.useEffect)(() => {
    onPageRenderFailRef.current = onPageRenderFail;
  }, [onPageRenderFail]);
  (0, import_react.useEffect)(() => {
    pdfjs.GlobalWorkerOptions.workerSrc = workerSrc;
  }, [workerSrc]);
  (0, import_react.useEffect)(() => {
    const config = { url: file, withCredentials };
    if (cMapUrl) {
      config.cMapUrl = cMapUrl;
      config.cMapPacked = cMapPacked;
    }
    pdfjs.getDocument(config).promise.then(
      (loadedPdfDocument) => {
        setPdfDocument(loadedPdfDocument);
        if (isFunction(onDocumentLoadSuccessRef.current)) {
          onDocumentLoadSuccessRef.current(loadedPdfDocument);
        }
      },
      () => {
        if (isFunction(onDocumentLoadFailRef.current)) {
          onDocumentLoadFailRef.current();
        }
      }
    );
  }, [file, withCredentials, cMapUrl, cMapPacked]);
  (0, import_react.useEffect)(() => {
    const drawPDF = (page2) => {
      const rotation = rotate === 0 ? page2.rotate : page2.rotate + rotate;
      const dpRatio = window.devicePixelRatio;
      const adjustedScale = scale * dpRatio;
      const viewport = page2.getViewport({ scale: adjustedScale, rotation });
      const canvasEl = canvasRef.current;
      if (!canvasEl) {
        return;
      }
      const canvasContext = canvasEl.getContext("2d");
      if (!canvasContext) {
        return;
      }
      canvasEl.style.width = `${viewport.width / dpRatio}px`;
      canvasEl.style.height = `${viewport.height / dpRatio}px`;
      canvasEl.height = viewport.height;
      canvasEl.width = viewport.width;
      if (renderTask.current) {
        renderTask.current.cancel();
        return;
      }
      renderTask.current = page2.render({
        canvasContext,
        viewport
      });
      return renderTask.current.promise.then(
        () => {
          renderTask.current = null;
          if (isFunction(onPageRenderSuccessRef.current)) {
            onPageRenderSuccessRef.current(page2);
          }
        },
        (reason) => {
          renderTask.current = null;
          if (reason && reason.name === "RenderingCancelledException") {
            drawPDF(page2);
          } else if (isFunction(onPageRenderFailRef.current)) {
            onPageRenderFailRef.current();
          }
        }
      );
    };
    if (pdfDocument) {
      pdfDocument.getPage(page).then(
        (loadedPdfPage) => {
          setPdfPage(loadedPdfPage);
          if (isFunction(onPageLoadSuccessRef.current)) {
            onPageLoadSuccessRef.current(loadedPdfPage);
          }
          drawPDF(loadedPdfPage);
        },
        () => {
          if (isFunction(onPageLoadFailRef.current)) {
            onPageLoadFailRef.current();
          }
        }
      );
    }
  }, [canvasRef, page, pdfDocument, rotate, scale]);
  return { pdfDocument, pdfPage };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  usePdf
});
